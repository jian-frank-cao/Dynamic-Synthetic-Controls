df = inner_join(exchange, targets, by = c("country_string" = "country"))
View(df)
df %>%
ggplot(aes(x = date, y = usdx, color = currency)) +
geom_line()
df_a = df %>% filter(currency == "EURO")
df_b = df %>% filter(currency == "GBP")
align = dtw::dtw(diff(t.normalize(df_a$index)),
diff(t.normalize(df_b$index)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
df_a
align = dtw::dtw(diff(t.normalize(df_a$usdx)),
diff(t.normalize(df_b$usdx)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
a = fitted(forecast::ets(W))
plot(ts(a))
df %>%
filter(currency %in% c("EURO", "us", "GBP")) %>%
ggplot(aes(x = date, y = usdx, color = currency)) +
geom_line()
plot(ts(df_a$usdx))
plot(ts(df_b$usdx))
align = dtw::dtw(diff(t.normalize(df_a$usdx)),
diff(t.normalize(df_b$usdx)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
align = dtw::dtw(diff(t.normalize(df_a$usdx)),
diff(t.normalize(df_b$usdx)),
keep = TRUE,
step.pattern = dtw::symmetric2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
plot(ts(W))
df_b = df %>% filter(currency == "AUD")
align = dtw::dtw(diff(t.normalize(df_a$usdx)),
diff(t.normalize(df_b$usdx)),
keep = TRUE,
step.pattern = dtw::symmetric2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
df %>%
# filter(currency %in% c("EURO", "GBP")) %>%
ggplot(aes(x = date, y = usdx, color = currency)) +
geom_line()
df %>%
filter(currency %in% c("EURO", "GBP", "AUD", "NZD",
"DKK", "NOK", "MAD", "CHF")) %>%
ggplot(aes(x = date, y = usdx, color = currency)) +
geom_line()
df_apple = readRDS("./data/df_apple.Rds")
df_ikea = readRDS("./data/df_ikea.Rds")
df_handm = readRDS("./data/df_handm.Rds")
df_zara = readRDS("./data/df_zara.Rds")
# compute index
df = rbind(df_apple, df_ikea, df_handm, df_zara) %>% # df_ikea,
group_by(country, date) %>%
summarise(avg_log = mean(avg_log, na.rm = TRUE)) %>%
ungroup() %>%
group_by(country) %>%
mutate(cum_log = cumsum(avg_log),
index = exp(cum_log))
# plot index
oecd = c("at", "ca", "dk", "fr", "de", "gr", "is", "ie", "be",
"lu", "nl", "no", "pt", "es", "se", "tr", "it", "ch",
"uk", "us")
df_oecd = df %>% filter(country %in% c("jp", oecd))
range_oecd = df_oecd %>%
group_by(country) %>%
summarise(min_date = min(date),
max_date = max(date))
select_country = range_oecd %>%
filter(min_date == as.Date("2009-04-01")) %>%
.[["country"]]
df %>%
filter(country %in% oecd) %>%
ggplot(aes(x = date, y = index, color = country)) +
geom_line()
currency = readRDS("./data/currency.Rds")
targets = currency %>%
group_by(currency) %>%
summarise(country = first(country))
df = inner_join(exchange, targets, by = c("country_string" = "country"))
df %>%
filter(currency %in% c("EURO", "GBP", "AUD", "NZD",
"DKK", "NOK", "MAD", "CHF")) %>%
ggplot(aes(x = date, y = usdx, color = currency)) +
geom_line()
df_a = df %>% filter(currency == "EURO")
df_b = df %>% filter(currency == "AUD")
## Setup -----------------------------------------------------------------------
library(checkpoint)
checkpoint("2022-04-01")
library(tidyverse)
?quantmod::getSymbols
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG", "XRB", "IFLD", "ILB", "IBGM")
data_list <- list()
# Loop over the symbols and download the data
for(symbol in symbols) {
data_list[[symbol]] <- quantmod::getSymbols(symbol, auto.assign = FALSE)
}
quantmod::getSymbols("AAPL")
# Install and load the package
install.packages("tidyquant")
# Install and load the package
install.packages("tidyquant")
library(tidyquant)
# Install and load the package
install.packages("tidyquant")
# Install and load the package
install.packages("tidyquant")
library(tidyquant)
# Get data
data <- tq_get(c("AAPL", "GOOG", "FB"),
from = "2020-01-01",
to = "2020-12-31")
## Setup -----------------------------------------------------------------------
library(checkpoint)
checkpoint("2022-04-01")
library(tidyverse)
library(tidyquant)
## Setup -----------------------------------------------------------------------
library(checkpoint)
checkpoint("2022-04-01")
library(tidyverse)
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG", "XRB", "IFLD", "ILB", "IBGM")
data_list <- list()
# Loop over the symbols and download the data
for(symbol in symbols) {
data_list[[symbol]] <- quantmod::getSymbols(symbol, auto.assign = FALSE)
}
quantmod::getSymbols("AAPL")
View(AAPL)
quantmod::getSymbols("INXG.L")
?quantmod::getSymbols
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.F", "IBCI.DE")
data_list <- list()
# Loop over the symbols and download the data
for(symbol in symbols) {
data_list[[symbol]] <- quantmod::getSymbols(symbol, auto.assign = FALSE)
}
View(data_list)
View(data_list)
data_list[["XRB.TO"]]
a = data.frame(data_list[[1]])
View(a)
a = data.frame(data_list[[2]])
a = data.frame(data_list[[3]])
a = data.frame(data_list[[4]])
a = data.frame(data_list[[5]])
a = data.frame(data_list[[4]])
symbol
response = data.frame(quantmod::getSymbols(symbol,
from = "2010-02-01",
to = "2022-12-31"))
View(response)
response = quantmod::getSymbols(symbol,
from = "2010-02-01",
to = "2022-12-31")
response = quantmod::getSymbols(symbol)
quantmod::getSymbols(symbol)
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.F", "IBCI.DE")
symbol = symbols[5]
symbol
quantmod::getSymbols(symbol)
quantmod::getSymbols(symbol, from = "2010-02-01", to = "2022-12-31")
View(IBCI.DE)
res = quantmod::getSymbols(symbol, from = "2010-02-01", to = "2022-12-31")
res = quantmod::getSymbols(symbol, auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
## Data ------------------------------------------------------------------------
symbols = c("INXG.L", "XRB.TO", "IBCI.F", "IBCI.DE")
data = quantmod::getSymbols("TIP", auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data = data %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.)),
ticker = "TIP")
View(data)
data = quantmod::getSymbols("TIP", auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data = data %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
.[,c(7:6)] %>%
colnames(c("date", "TIP"))
data2 = data %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
.[,c(7:6)]
View(data2)
data = quantmod::getSymbols("TIP", auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data2 = data %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", "TIP"))
View(data)
View(data2)
data2 = data %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
`rownames<-`(NULL) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", "TIP"))
View(data2)
data = data %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
`rownames<-`(NULL) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", "TIP"))
data2 = data
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.F", "IBCI.DE")
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.F", "IBCI.DE")
data_list = NULL
# Loop over the symbols and download the data
for(symbol in symbols) {
response = quantmod::getSymbols(symbol, auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data_list[[symbol]] = response %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
`rownames<-`(NULL) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", symbol))
}
data = Reduce(function(...) merge(..., by = "date", all = TRUE), data_list)
View(data)
df <- data.frame(
a = c(1, NA, 2, NA, NA, 3),
b = c(NA, NA, 4, NA, 5, NA)
)
# Fill the missing values
df_filled <- df %>% fill(a, b)
df_filled
# Fill the missing values
df_filled <- df %>% fill(a)
df_filled
# Fill the missing values
df_filled <- df %>% fill()
df_filled
data = data %>% fill(select(data, -1))
cols_to_fill <- names(data)[-1]
cols_to_fill
data = Reduce(function(...) merge(..., by = "date", all = TRUE), data_list)
cols_to_fill <- names(data)[-1]
data = data %>% fill(cols_to_fill)
data = Reduce(function(...) merge(..., by = "date", all = TRUE), data_list)
data = data %>% fill(all_of(data))
cols_to_fill <- names(data)[-1]
data = data %>% fill(all_of(cols_to_fill))
View(data)
View(data)
?reshape2::melt
## Run -------------------------------------------------------------------------
df = reshape2::melt(data, id.vars = 1)
View(df)
df %>%
ggplot(aes(x = date, y = value, color = variable)) +
geom_line()
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.DE", "ILB.XA", "XSTH.TO")
data_list = NULL
# Loop over the symbols and download the data
for(symbol in symbols) {
response = quantmod::getSymbols(symbol, auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data_list[[symbol]] = response %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
`rownames<-`(NULL) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", symbol))
}
data = Reduce(function(...) merge(..., by = "date", all = TRUE), data_list)
cols_to_fill <- names(data)[-1]
data = data %>% fill(all_of(cols_to_fill))
## Functions -------------------------------------------------------------------
# normalization
t.normalize = function(data, reference = NULL){
if (is.null(reference)) {
mu = mean(data)
sigma = sd(data)
}else{
mu = mean(reference)
sigma = sd(reference)
}
res = (data - mu)/sigma
return(res)
}
# transform warping path W to weight
warp2weight = function(W){
w = as.matrix(W)
count = rep(1/colSums(w), nrow(w)) %>%
matrix(.,
nrow = ncol(w),
ncol = nrow(w)) %>%
t(.)
weight = rowSums(w * count)
return(weight)
}
## Run -------------------------------------------------------------------------
df = reshape2::melt(data, id.vars = 1)
df %>%
ggplot(aes(x = date, y = value, color = variable)) +
geom_line()
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.DE", "GTIP") #, "ILB.XA", "XSTH.TO"
data_list = NULL
# Loop over the symbols and download the data
for(symbol in symbols) {
response = quantmod::getSymbols(symbol, auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data_list[[symbol]] = response %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
`rownames<-`(NULL) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", symbol))
}
data = Reduce(function(...) merge(..., by = "date", all = TRUE), data_list)
cols_to_fill <- names(data)[-1]
data = data %>% fill(all_of(cols_to_fill))
## Functions -------------------------------------------------------------------
# normalization
t.normalize = function(data, reference = NULL){
if (is.null(reference)) {
mu = mean(data)
sigma = sd(data)
}else{
mu = mean(reference)
sigma = sd(reference)
}
res = (data - mu)/sigma
return(res)
}
# transform warping path W to weight
warp2weight = function(W){
w = as.matrix(W)
count = rep(1/colSums(w), nrow(w)) %>%
matrix(.,
nrow = ncol(w),
ncol = nrow(w)) %>%
t(.)
weight = rowSums(w * count)
return(weight)
}
## Run -------------------------------------------------------------------------
df = reshape2::melt(data, id.vars = 1)
df %>%
ggplot(aes(x = date, y = value, color = variable)) +
geom_line()
## Data ------------------------------------------------------------------------
symbols = c("TIP", "INXG.L", "XRB.TO", "IBCI.DE") #, "GTIP" , "ILB.XA", "XSTH.TO"
data_list = NULL
# Loop over the symbols and download the data
for(symbol in symbols) {
response = quantmod::getSymbols(symbol, auto.assign = FALSE,
from = "2010-02-01", to = "2022-12-31")
data_list[[symbol]] = response %>%
data.frame(.) %>%
mutate(date = as.Date(rownames(.))) %>%
`rownames<-`(NULL) %>%
.[,c(7:6)] %>%
`colnames<-`(c("date", symbol))
}
data = Reduce(function(...) merge(..., by = "date", all = TRUE), data_list)
cols_to_fill <- names(data)[-1]
data = data %>% fill(all_of(cols_to_fill))
## Functions -------------------------------------------------------------------
# normalization
t.normalize = function(data, reference = NULL){
if (is.null(reference)) {
mu = mean(data)
sigma = sd(data)
}else{
mu = mean(reference)
sigma = sd(reference)
}
res = (data - mu)/sigma
return(res)
}
# transform warping path W to weight
warp2weight = function(W){
w = as.matrix(W)
count = rep(1/colSums(w), nrow(w)) %>%
matrix(.,
nrow = ncol(w),
ncol = nrow(w)) %>%
t(.)
weight = rowSums(w * count)
return(weight)
}
## Run -------------------------------------------------------------------------
df = reshape2::melt(data, id.vars = 1)
df %>%
ggplot(aes(x = date, y = value, color = variable)) +
geom_line()
df_a = data$TIP
df_b = data$INXG.L
align = dtw::dtw(diff(t.normalize(df_a$index)),
diff(t.normalize(df_b$index)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
df_b = data$XRB.TO
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
plot(ts(W))
df_b = data$INXG.L
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(W))
plot(data$date, ts(W))
?ts
plot(ts(a))
df_b = data$IBCI.DE
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetric2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
# dtw
df_a = data$TIP
df_b = data$INXG.L
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetric2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
align = dtw::dtw(diff(t.normalize(df_a)),
diff(t.normalize(df_b)),
keep = TRUE,
step.pattern = dtw::symmetricP2)
dtw::dtwPlotThreeWay(align)
P = Matrix::sparseMatrix(align$index1,
align$index2)
W = warp2weight(P)
a = fitted(forecast::ets(W))
plot(ts(a))
data[2250,]
# plot
df %>%
ggplot(aes(x = date, y = value, color = variable)) +
geom_line()
365*15
